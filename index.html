<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>Oligopolies</title>
    <link rel="stylesheet" type="text/css" href="style.css" />
    <link
      href="https://fonts.googleapis.com/css?family=Karla&display=swap"
      rel="stylesheet"
    />
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
  </head>

  <body>
    <div id="cbp-fbscroller" class="cbp-fbscroller">
      <nav>
        <a href="#fbsection1" class="cbp-fbcurrent">Section 1</a>
        <a href="#fbsection2" onclick="start()">Section 2</a>
        <a href="#fbsection3" onclick="test()">Section 3</a>
        <a href="#fbsection4">Section 4</a>
        <a href="#fbsection5">Section 5</a>
      </nav>

      <section id="fbsection1">
        <div class="container4">
          <h1>Oligipolies</h1>
        </div>

        <div id="bottom" style="text-align:center;">
          <svg
            class="mouse"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 76 130"
            preserveAspectRatio="xMidYMid meet"
          >
            <g fill="none" fill-rule="evenodd">
              <rect
                width="70"
                height="118"
                x="1.5"
                y="1.5"
                stroke="#FFF"
                stroke-width="3"
                rx="36"
              />
              <circle class="scroll" cx="36.5" cy="31.5" r="4.5" fill="#FFF" />
            </g>
          </svg>
        </div>
      </section>

      <section id="fbsection2">
        <div class="center">
          <p id="text">
            a state of limited competition, in which a market is shared by a
            small number of producers or sellers.
          </p>
        </div>
      </section>

      <section id="fbsection3">
        <h1>Works3</h1>
      </section>
      <section id="fbsection4">
        <h1>Works4</h1>
      </section>
      <section id="fbsection5">
        <h1>Works5</h1>
      </section>
    </div>

    <script>
      function test() {
        var margin = { top: 50, right: 50, bottom: 50, left: 50 };
        var width = window.innerWidth,
          height = window.innerHeight;

        var svg = d3
          .select("#fbsection3")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform", "translate(" + [margin.left, margin.top] + ")");

        var config = {
          radius: 5,
          gridLength: 10,
          gridPadding: 10
        };

        var defs = svg.append("defs");
        var filter = defs.append("filter").attr("id", "gooey");
        filter
          .append("feGaussianBlur")
          .attr("in", "SourceGraphic")
          .attr("stdDeviation", config.radius * 1.8)
          .attr("result", "blur");
        filter
          .append("feColorMatrix")
          .attr("class", "blurValues")
          .attr("in", "blur")
          .attr("mode", "matrix")
          .attr(
            "values",
            "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 " + config.radius + " -6"
          )
          .attr("result", "gooey");
        filter
          .append("feBlend")
          .attr("in", "SourceGraphic")
          .attr("in2", "gooey")
          .attr("operator", "atop");

        var data = d3.range(60).map(function(i) {
          return {
            r: config.radius,
            colour: "white"
          };
        });

        var simulation = d3
          .forceSimulation(data)
          .force("x", d3.forceX(width / 2))
          .force("y", d3.forceY(height / 2))
          .force("collide", d3.forceCollide(config.radius + 1.5).iterations(2))
          .stop();

        var circleGroup = svg.append("g").style("filter", "url(#gooey)");

        var smallCircles = circleGroup
          .append("g")
          .selectAll("circle")
          .data(data)
          .enter()
          .append("circle")
          .attr("class", "small-circle")
          .attr("r", config.radius)
          .attr(
            "cx",
            (d, i) =>
              (d.x =
                (i % config.gridLength) *
                (config.gridPadding + config.radius * 2))
          )
          .attr(
            "cy",
            (d, i) =>
              (d.y =
                Math.floor(i / config.gridLength) *
                (config.gridPadding + config.radius * 2))
          )
          .attr("fill", d => d.colour);

        var bigCircle = circleGroup
          .append("g")
          .append("circle")
          .attr("class", "big-circle")
          .attr("cx", width / 2)
          .attr("cy", height / 2)
          .attr("r", 0)
          .style("fill", "white");

        function clusterDots() {
          // Interpolate between gooey filter and no gooey filter
          transitionGoo(3000);

          for (var i = 0; i < 120; ++i) simulation.tick();

          d3.selectAll(".small-circle")
            .transition()
            .duration(1500)
            .delay((d, i) => calculateDistance(d, [width / 2, height / 2]) * 30)
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);

          d3.select(".big-circle")
            .transition()
            .delay(700)
            .duration(2500)
            .attr("r", Math.sqrt(data.length) * 1.5 * config.radius);
        }

        function separateDots() {
          transitionGooBack(2000);

          d3.select(".big-circle")
            .transition()
            .duration(2100)
            .attr("r", 0);

          d3.selectAll(".small-circle")
            .transition()
            .duration(1500)
            .delay(
              (d, i) =>
                1500 +
                (config.radius -
                  calculateDistance(d, [width / 2, height / 2])) *
                  30
            )
            .attr(
              "cx",
              (d, i) =>
                (i % config.gridLength) *
                (config.gridPadding + config.radius * 2)
            )
            .attr(
              "cy",
              (d, i) =>
                Math.floor(i / config.gridLength) *
                (config.gridPadding + config.radius * 2)
            );
        }

        function loop() {
          setTimeout(clusterDots, 1000);
          setTimeout(separateDots, data.length * 150);
        }

        loop();
        setInterval(loop, data.length * 200);

        function transitionGoo(duration) {
          d3.selectAll(".blurValues")
            .transition()
            .duration(duration)
            .attrTween("values", function() {
              return d3.interpolateString(
                "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 6 -6",
                "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 " +
                  config.radius * 8 +
                  " -6"
              );
            });
        }

        function transitionGooBack(duration) {
          d3.selectAll(".blurValues")
            .transition()
            .duration(duration)
            .attrTween("values", function() {
              return d3.interpolateString(
                "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 " +
                  config.radius * 8 +
                  " -6",
                "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 6 -6"
              );
            });
        }

        function calculateDistance(d, point) {
          return Math.sqrt(
            Math.pow(point[0] - d.x, 2) + Math.pow(point[1] - d.y, 2)
          );
        }

        d3.select("body").attr("align", "center");
      }
    </script>
    <script src="script.js"></script>
    <script src="animation.js"></script>
  </body>
</html>
